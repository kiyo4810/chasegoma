<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>ã‚´ãƒã¡ã‚ƒã‚“ã‚’è¿½ãˆ - Fullscreen</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        touch-action: none;
      }

      html, body {
        width: 100%;
        height: 100%;
        overflow: hidden;
        background-color: #0a0a32;
      }

      canvas {
        display: block;
        width: 100vw;
        height: 100vh;
        cursor: pointer;
      }

      /* ãƒ‰ãƒ©ãƒƒã‚°å¯èƒ½ãªéŸ³é‡ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ */
      #volume-container {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 1000;
        background: rgba(255, 255, 255, 0.1);
        padding: 15px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        cursor: move;
        user-select: none;
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
      }

      .volume-label {
        color: white;
        font-size: 14px;
        font-family: sans-serif;
        pointer-events: none;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
      }

      input[type="range"] {
        cursor: pointer;
        width: 100px;
      }
    </style>
  </head>
  <body>
    <div id="volume-container">
      <div class="volume-label">ğŸ”Š <span id="volumeValue">70</span>%</div>
      <input type="range" id="volumeSlider" min="0" max="100" value="70" />
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const volumeContainer = document.getElementById("volume-container");
      const volumeSlider = document.getElementById("volumeSlider");
      const volumeValue = document.getElementById("volumeValue");

      // --- ã‚²ãƒ¼ãƒ è¨­å®š ---
      let score = 0;
      let spriteX = 0;
      let spriteY = 0;
      let spriteSpeed = [0, 0]; // æœ€åˆã¯å‹•ã‹ã•ãªã„
      let volume = 70;
      let isGameStarted = false;

      const catSound = new Audio("images/cat.mp3");
      const specialSound = new Audio("images/special.mp3");
      
      const spriteImage = new Image();
      spriteImage.src = "images/goma.png";
      let isImageLoaded = false;
      spriteImage.onload = () => { isImageLoaded = true; };

      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        if (!isGameStarted) {
          spriteX = canvas.width / 2;
          spriteY = canvas.height / 2;
        }
      }
      window.addEventListener("resize", resize);
      resize();

      // --- éŸ³é‡èª¿æ•´ã¨ãƒ‰ãƒ©ãƒƒã‚°æ©Ÿèƒ½ ---
      volumeSlider.addEventListener("input", (e) => {
        volume = parseInt(e.target.value);
        volumeValue.textContent = volume;
      });

      let isDragging = false;
      let offset = { x: 0, y: 0 };

      const startDrag = (e) => {
        if (e.target === volumeSlider) return;
        isDragging = true;
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        offset.x = clientX - volumeContainer.offsetLeft;
        offset.y = clientY - volumeContainer.offsetTop;
      };

      const doDrag = (e) => {
        if (!isDragging) return;
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        volumeContainer.style.left = Math.max(0, Math.min(window.innerWidth - volumeContainer.offsetWidth, clientX - offset.x)) + "px";
        volumeContainer.style.top = Math.max(0, Math.min(window.innerHeight - volumeContainer.offsetHeight, clientY - offset.y)) + "px";
      };

      volumeContainer.addEventListener("mousedown", startDrag);
      window.addEventListener("mousemove", doDrag);
      window.addEventListener("mouseup", () => isDragging = false);
      volumeContainer.addEventListener("touchstart", startDrag);
      window.addEventListener("touchmove", doDrag);
      window.addEventListener("touchend", () => isDragging = false);

      function playSuccessSound() {
        let targetSound = (score > 0 && score % 10 === 0) ? specialSound : catSound;
        targetSound.volume = volume / 100;
        targetSound.currentTime = 0;
        targetSound.play().catch(() => {});
      }

      function update() {
        if (!isGameStarted) return;
        spriteX += spriteSpeed[0];
        spriteY += spriteSpeed[1];

        const bounceMargin = 40;
        if (spriteX < bounceMargin || spriteX > canvas.width - bounceMargin) spriteSpeed[0] *= -1;
        if (spriteY < bounceMargin || spriteY > canvas.height - bounceMargin) spriteSpeed[1] *= -1;
      }

      function draw() {
        // èƒŒæ™¯ã‚¯ãƒªã‚¢
        ctx.fillStyle = "#0a0a32";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 1. ã‚¿ã‚¤ãƒˆãƒ«ï¼ˆèƒŒæ™¯ã¨ã—ã¦æç”»ï¼‰
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(255, 255, 255, 0.15)"; // ã‹ãªã‚Šè–„ã
        const titleFontSize = Math.min(canvas.width / 10, 80);
        ctx.font = `bold ${titleFontSize}px sans-serif`;
        ctx.fillText("ã‚´ãƒã¡ã‚ƒã‚“ã‚’è¿½ãˆ", canvas.width / 2, 100);

        // 2. ã‚¹ã‚¿ãƒ¼ãƒˆæ¡ˆå†…ï¼ˆæœªé–‹å§‹æ™‚ã®ã¿ï¼‰
        if (!isGameStarted) {
          ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
          ctx.font = "20px Arial";
          ctx.fillText("ç”»é¢ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚¹ã‚¿ãƒ¼ãƒˆï¼", canvas.width / 2, canvas.height / 2 + 100);
        }

        // 3. ã‚¹ã‚³ã‚¢ï¼ˆä¸‹éƒ¨ä¸­å¤®ï¼‰
        ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
        ctx.font = "bold 24px Arial";
        ctx.fillText(`Score: ${score}`, canvas.width / 2, canvas.height - 50);

        // 4. ã‚´ãƒã¡ã‚ƒã‚“æç”»
        const size = Math.min(canvas.width, canvas.height) * 0.15;
        if (isImageLoaded) {
          ctx.drawImage(spriteImage, spriteX - size / 2, spriteY - size / 2, size, size);
        } else {
          ctx.fillStyle = "white";
          ctx.beginPath();
          ctx.arc(spriteX, spriteY, size/3, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
      }

      function handleClick(e) {
        if (e.target.closest("#volume-container")) return;

        if (!isGameStarted) {
          isGameStarted = true;
          spriteSpeed = [3, 3];
          return;
        }

        const clientX = (e.touches ? e.touches[0].clientX : e.clientX);
        const clientY = (e.touches ? e.touches[0].clientY : e.clientY);

        const dist = Math.sqrt(Math.pow(clientX - spriteX, 2) + Math.pow(clientY - spriteY, 2));
        const hitLimit = Math.min(canvas.width, canvas.height) * 0.15;

        if (dist < hitLimit) {
          score++;
          spriteX = Math.random() * (canvas.width - 100) + 50;
          spriteY = Math.random() * (canvas.height - 100) + 50;
          spriteSpeed[0] *= 1.05;
          spriteSpeed[1] *= 1.05;
          playSuccessSound();
        }
      }

      canvas.addEventListener("mousedown", handleClick);
      canvas.addEventListener("touchstart", (e) => {
        e.preventDefault();
        handleClick(e);
      }, { passive: false });

      loop();
    </script>
  </body>
</html>
